---
title: "Comparison of all pipelines"
subtitle: "{{< meta subtitle_seurat >}} {{< meta subtitle_bioc >}} {{< meta subtitle_scanpy >}}"
description: "Overview of all three pipeline results."
format: html
---


{{< meta qc_data_2 >}}

```{r}
suppressPackageStartupMessages({
    library(Seurat)
    library(zellkonverter)
    library(Matrix)
    library(ggplot2)
    library(patchwork)
    library(scran)
    library(ComplexHeatmap)
})
```


## Load data



OBS! Zellkonverter installs conda env with basilisk! Takes a while to run first time!!


```{r}
path_results <- "data/covid/results"
if (!dir.exists(path_results)) dir.create(path_results, recursive = T)

path_seurat = "../seurat/data/covid/results/"
path_bioc = "../bioc/data/covid/results/"
path_scanpy = "../scanpy/data/covid/results/"

# fetch the files with qc and dimred for each 

# seurat
sobj = readRDS(file.path(path_seurat,"seurat_covid_qc_dr_int_cl.rds"))

# bioc
sce = readRDS(file.path(path_bioc,"bioc_covid_qc_dr_int_cl.rds"))
bioc = as.Seurat(sce)

# scanpy
scanpy.sce = readH5AD(file.path(path_scanpy, "scanpy_covid_qc_dr_scanorama_cl.h5ad"))
scanpy = as.Seurat(scanpy.sce, counts = NULL, data = "X") # only have the var.genes data that is scaled.

```

```{r}
#| fig-height: 4
#| fig-width: 10

wrap_plots(
    DimPlot(sobj, group.by = "orig.ident") + NoAxes() + ggtitle("Seurat"),
    DimPlot(bioc, group.by = "sample") + NoAxes() + ggtitle("Bioc"),
    DimPlot(scanpy, group.by = "sample", reduction = "X_umap_uncorr") + NoAxes() + ggtitle("Scanpy"),
    ncol = 3
)
```



```{r}
cat("Seurat: ", dim(sobj),"\n")
cat("Bioc: ", dim(bioc),"\n")
cat("Scanpy: ", dim(scanpy),"\n")

```


Highest number of cells filtered with Bioc. Lowest with scanpy.

Cell names are different in all 3, have to make a conversion to match them. 

* Seurat has the sample name merged to cell name.
* Scanpy has sample number after cell name. 
* Bioc has just cell name.

```{r}
meta.seurat = sobj@meta.data
meta.scanpy = scanpy@meta.data
meta.bioc = bioc@meta.data

meta.bioc$cell = rownames(meta.bioc)
meta.scanpy$cell = sapply(rownames(meta.scanpy), function(x) substr(x,1,nchar(x)-2))
meta.seurat$cell = unlist(lapply(strsplit(rownames(meta.seurat),"_"), function(x) x[3]))
```

## Doublet predictions

In all 3 pipelines we run the filtering of cells in the exact same way, but doublet detection is different.

* In Seurat - `DoubletFinder` with predefined 4% doublets.
* In Scanpy - `Scrublet`, done per batch. No predefined cutoff. 
* In Bioc - `scDblFinder` - default cutoffs, no batch separation. 

Visualize overlap of cells using an UpSet plot in the `ComplexHeatmap` package.

```{r}
l = list(seurat = meta.seurat$cell, bioc = meta.bioc$cell, scanpy = meta.scanpy$cell)

cmat = make_comb_mat(l)
print(cmat)

UpSet(cmat)
```

### Doublet scores

Create one dataset with the cells that are present in all samples. Also add in umap from all 3 pipelines.

```{r}
in.all = intersect(intersect(meta.scanpy$cell, meta.seurat$cell), meta.bioc$cell)

tmp1 = meta.bioc[match(in.all, meta.bioc$cell),]
colnames(tmp1) = paste0(colnames(tmp1),"_bioc")
tmp2 = meta.scanpy[match(in.all, meta.scanpy$cell),]
colnames(tmp2) = paste0(colnames(tmp2),"_scpy")

all = sobj[,match(in.all, meta.seurat$cell)]

meta.all = cbind(all@meta.data, tmp1,tmp2)
all@meta.data = meta.all

Reductions(all)

tmp = bioc@reductions$UMAP_on_PCA@cell.embeddings[match(in.all, meta.bioc$cell),]
rownames(tmp) = colnames(all)
all[["umap_bioc"]] = CreateDimReducObject(tmp, key = "umapbioc_", assay = "RNA")
tmp = scanpy@reductions$X_umap_uncorr@cell.embeddings[match(in.all, meta.scanpy$cell),]
rownames(tmp) = colnames(all)
all[["umap_scpy"]] = CreateDimReducObject(tmp, key = "umapscpy_", assay = "RNA")

Reductions(all)
```


```{r}
#| fig-height: 4
#| fig-width: 10

wrap_plots(
  FeatureScatter(all, "pANN_0.25_0.09_297","scDblFinder.score_bioc"),
  FeatureScatter(all, "pANN_0.25_0.09_297","doublet_scores_scpy"),
 FeatureScatter(all, "scDblFinder.score_bioc","doublet_scores_scpy"),
  ncol = 3 
) + plot_layout(guides = "collect")
```

Highest correlation for the doublet scores in Scrublet and scDblFinder, but still only 0.27 in correlation.

```{r}
#| fig-height: 10
#| fig-width: 10

wrap_plots(
  FeaturePlot(all, reduction = "umap", features = "pANN_0.25_0.09_297") + NoAxes(),
  FeaturePlot(all, reduction = "umap", features = "scDblFinder.score_bioc") + NoAxes(),
  FeaturePlot(all, reduction = "umap", features = "doublet_scores_scpy") + NoAxes(),
  FeaturePlot(all, reduction = "umap_bioc", features = "pANN_0.25_0.09_297") + NoAxes(),
  FeaturePlot(all, reduction = "umap_bioc", features = "scDblFinder.score_bioc") + NoAxes(),
  FeaturePlot(all, reduction = "umap_bioc", features = "doublet_scores_scpy") + NoAxes(),  
  FeaturePlot(all, reduction = "umap_scpy", features = "pANN_0.25_0.09_297") + NoAxes(),
  FeaturePlot(all, reduction = "umap_scpy", features = "scDblFinder.score_bioc") + NoAxes(),
  FeaturePlot(all, reduction = "umap_scpy", features = "doublet_scores_scpy") + NoAxes(),  
  ncol = 3
) + plot_layout(guides = "collect")
```

It seems like the DoubletFinder scores are mainly high in the monocyte populations, while it is more mixed in the other 2 methods.

## Cell cycle

Cell cycle predictions are done in a similar way for Seurat and Scanpy using module scores, while in Bioc we are using Cyclone. 

Visualize the phase predictions onto the Seurat umap.

```{r}
#| fig-height: 4
#| fig-width: 10

table(all$Phase)
table(all$phase_bioc)
table(all$phase_scpy)

wrap_plots(
DimPlot(all, group.by = "Phase") + NoAxes(),
DimPlot(all, group.by = "phase_bioc") + NoAxes(),
DimPlot(all, group.by = "phase_scpy") + NoAxes(),
  ncol = 3 
) + plot_layout(guides = "collect")
```
In seurat, most T/B-cells look like cycling.
With bioc, more mixed. 
With scanpy also more in B/T-cells, but much more G1 prediction.


## Variable features

In Seurat, `FindVariableFeatures` is not batch aware unless the data is split into layers by samples, here we have the variable genes created with layers. In Bioc `modelGeneVar` we used sample as a blocking parameter, e.g calculates the variable genes per sample and combines the variances. Similar in scanpy we used the samples as `batch_key`. 


```{r}
hvgs = list()
hvgs$seurat = VariableFeatures(sobj)
hvgs$bioc = sce@metadata$hvgs
# scanpy has no strict number on selection, instead uses dispersion cutoff. So select instead top 2000 dispersion genes.
tmp = rowData(scanpy.sce)
hvgs_scanpy = rownames(tmp)[tmp$highly_variable]
hvgs$scanpy = rownames(tmp)[order(tmp$dispersions_norm, decreasing = T)][1:2000]

cmat = make_comb_mat(hvgs)
print(cmat)

UpSet(cmat)
```
Surprisingly low overlap between the methods and many genes that are unique to one pipeline. With discrepancies in the doublet filtering the cells used differ to some extent, but otherwise the variation should be similar. Even if it is estimated in different ways.

Is the differences more due to the combination of ranks/dispersions or also found within a single dataset?

Only Seurat have the dispersions for each individual dataset stored in the object. 

### Same set of cells

For a fair comparison, select one sample and rerun for the same exact set of cells. 


```{r}
# Bioc
sce.sel = sce[,match(in.all, meta.bioc$cell)]

var.out <- modelGeneVar(sce.sel, block = sce.sel$sample)
hvgs_bioc <- getTopHVGs(var.out, n = 2000)
```

```{r}
# Seurat, have all the same cells in the object `all` 

all = FindVariableFeatures(all)
```

```{r}
# with different cells
length(intersect(hvgs$bioc, hvgs$seurat))

# with same set of cells
length(intersect(hvgs_bioc, VariableFeatures(all)))
```

Still very low overlap, now the main difference is the sample blocking parameter. But also Seurat was run for each layer separately and then combined the ranks.  So instead run for one sample.

### For one sample

Compare for ctrl.13 sample, Seurat uses `variance.standardized` to rank the genes. Bioc uses the `bio` slot with estimated biological variation.   

```{r}
tmpB = var.out$per.block$ctrl.13
tmpS = all@assays$RNA@meta.data
rownames(tmpS) = rownames(all)

# genes are in same order in both objects. So just plot vs eachoter.
plot(tmpS$vf_vst_counts.ctrl_13_variance.standardized, tmpB$bio)
tmp = cbind(tmpB, tmpS)
tmp$gene = rownames(tmp)

ggplot(tmp, aes(x=vf_vst_counts.ctrl_13_variance.standardized, y=bio, color="red")) + geom_point() + geom_text(data=subset(tmp, vf_vst_counts.ctrl_13_variance.standardized > 7 | bio > 3),aes(vf_vst_counts.ctrl_13_variance.standardized,bio,label=gene), color="black")
```

The variance estimate for the same sample is quite different. Even the top variable genes are not the same and are very different gene groups.

Try the different methods implemented in Seurat. From the help section:

* “vst”: First, fits a line to the relationship of log(variance) and log(mean) using local polynomial regression (loess). Then standardizes the feature values using the observed mean and expected variance (given by the fitted line). Feature variance is then calculated on the standardized values after clipping to a maximum (see clip.max parameter).
* “mean.var.plot” (mvp): First, uses a function to calculate average expression (mean.function) and dispersion (dispersion.function) for each feature. Next, divides features into num.bin (deafult 20) bins based on their average expression, and calculates z-scores for dispersion within each bin. The purpose of this is to identify variable features while controlling for the strong relationship between variability and average expression
* “dispersion” (disp): selects the genes with the highest dispersion values



```{r}
all = FindVariableFeatures(all, selection.method = "mean.var.plot")

tmpS = all@assays$RNA@meta.data
rownames(tmpS) = rownames(all)

tmp = cbind(tmpB, tmpS)
tmp$gene = rownames(tmp)

length(intersect(hvgs$seurat, VariableFeatures(all)))
hvgs$seurat_mvp = VariableFeatures(all)

ggplot(tmp, aes(x=vf_vst_counts.ctrl_13_variance.standardized, y=vf_mvp_data.ctrl_13_mvp.dispersion.scaled, color="red")) + geom_point() + geom_text(data=subset(tmp, vf_vst_counts.ctrl_13_variance.standardized > 7 | vf_mvp_data.ctrl_13_mvp.dispersion.scaled > 7),aes(vf_vst_counts.ctrl_13_variance.standardized,vf_mvp_data.ctrl_13_mvp.dispersion.scaled,label=gene), color="black")
```

Also quite different between the methods!

```{r}
all = FindVariableFeatures(all, selection.method = "dispersion")

tmpS = all@assays$RNA@meta.data
rownames(tmpS) = rownames(all)

tmp = cbind(tmpB, tmpS)
tmp$gene = rownames(tmp)

length(intersect(hvgs$seurat, VariableFeatures(all)))
hvgs$seurat_disp = VariableFeatures(all)

ggplot(tmp, aes(x=vf_vst_counts.ctrl_13_variance.standardized, y=vf_disp_data.ctrl_13_mvp.dispersion.scaled, color="red")) + geom_point() + geom_text(data=subset(tmp, vf_vst_counts.ctrl_13_variance.standardized > 7 | vf_disp_data.ctrl_13_mvp.dispersion.scaled > 7),aes(vf_vst_counts.ctrl_13_variance.standardized,vf_disp_data.ctrl_13_mvp.dispersion.scaled,label=gene), color="black")

ggplot(tmp, aes(x=vf_mvp_data.ctrl_13_mvp.dispersion.scaled, y=vf_disp_data.ctrl_13_mvp.dispersion.scaled, color="red")) + geom_point() + geom_text(data=subset(tmp, vf_mvp_data.ctrl_13_mvp.dispersion.scaled > 7 | vf_disp_data.ctrl_13_mvp.dispersion.scaled > 7),aes(vf_mvp_data.ctrl_13_mvp.dispersion.scaled,vf_disp_data.ctrl_13_mvp.dispersion.scaled,label=gene), color="black")


```
Identical results with "dispersion" or "mean.var.plot"!

Compare mvp to Bioc. 

```{r}
ggplot(tmp, aes(x=vf_disp_data.ctrl_13_mvp.dispersion.scaled, y=bio, color="red")) + geom_point() + geom_text(data=subset(tmp, vf_disp_data.ctrl_13_mvp.dispersion.scaled > 7 | bio > 3),aes(vf_disp_data.ctrl_13_mvp.dispersion.scaled,bio,label=gene), color="black")
```

Explore top  genes with vst,  bioc and scanpy

```{r}
topB = rownames(tmp)[order(tmp$bio, decreasing = T)][1:10]
topS = rownames(tmp)[order(tmp$vf_vst_counts.ctrl_13_variance.standardized, decreasing = T)][1:10]

tmp2 = rowData(scanpy.sce)
topSP = rownames(tmp2)[order(tmp2$dispersions_norm, decreasing = T)][1:10]
```

We have some overlapping genes:

```{r}
cat("Bioc" , topB, "\n")
cat("Seurat", topS, "\n") 
cat("Scanpy", topSP, "\n")
cat("Bioc & Seurat", intersect(topS,topB), "\n")
cat("Scanpy & Seurat", intersect(topS,topSP), "\n")
cat("Bioc & Scanpy", intersect(topB,topSP), "\n")
```



```{r}
#| fig-height: 10
#| fig-width: 12
FeaturePlot(all, features = c(topB,topS,topSP), order = T, ncol=5)
```

More clear celltype genes in the Bioc selection. More B-cell genes for Scanpy/Seurat.

## Integrations

```{r}
reductions = c("umap","umap_cca", "umap_harmony",  "umap_scanorama",    "umap_scanoramaC", "umap_bioc",  "umap_bioc_mnn", "umap_bioc_harmony", "umap_bioc_scanorama", "umap_scpy","umap_scpy_bbknn", "umap_scpy_scanorama", "umap_scpy_harmony"   )

tmp = bioc@reductions$UMAP_on_MNN@cell.embeddings[match(in.all, meta.bioc$cell),]
rownames(tmp) = colnames(all)
all[["umap_bioc_mnn"]] = CreateDimReducObject(tmp, key = "umapbiocmnn_", assay = "RNA")

tmp = bioc@reductions$UMAP_on_Harmony@cell.embeddings[match(in.all, meta.bioc$cell),]
rownames(tmp) = colnames(all)
all[["umap_bioc_harmony"]] = CreateDimReducObject(tmp, key = "umapbiocharmony_", assay = "RNA")

tmp = bioc@reductions$UMAP_on_Scanorama@cell.embeddings[match(in.all, meta.bioc$cell),]
rownames(tmp) = colnames(all)
all[["umap_bioc_scanorama"]] = CreateDimReducObject(tmp, key = "umapbioscanorama_", assay = "RNA")

tmp = scanpy@reductions$X_umap_bbknn@cell.embeddings[match(in.all, meta.scanpy$cell),]
rownames(tmp) = colnames(all)
all[["umap_scpy_bbknn"]] = CreateDimReducObject(tmp, key = "umapscpybbknn_", assay = "RNA")

tmp = scanpy@reductions$X_umap_scanorama@cell.embeddings[match(in.all, meta.scanpy$cell),]
rownames(tmp) = colnames(all)
all[["umap_scpy_scanorama"]] = CreateDimReducObject(tmp, key = "umapscpyscanorama_", assay = "RNA")

tmp = scanpy@reductions$X_umap_harmony@cell.embeddings[match(in.all, meta.scanpy$cell),]
rownames(tmp) = colnames(all)
all[["umap_scpy_harmony"]] = CreateDimReducObject(tmp, key = "umapscpyharmony_", assay = "RNA")

```


```{r}
#| fig-height: 10
#| fig-width: 12
plotlist = lapply(reductions, function(x) DimPlot(all, reduction = x, group.by = "orig.ident") + NoAxes() + ggtitle(x))

wrap_plots(
  plotlist,
  ncol = 4
) + plot_layout(guides = "collect")
```

```{r}
# remotes::install_github("carmonalab/scIntegrationMetrics", dependencies = FALSE), fails with compiler errors on mac. 
```

### Clustering on integrations

Run clustering on each of the integrations but with same method. Use Seurat, with 30 first components, k=30, and louvain with a few different resolutions.

For BBKNN the full integration matrix is not in the reductions, skip for now.


```{r}
# all seurat integrations.

integrations = list(
  seu_cca = "integrated_cca",
  seu_harm = "harmony",
  seu_scan = "scanorama",
  seu_scanC = "scanoramaC"
)
res = c(0.4,0.6,0.8,1.0)

for (i in 1:length(integrations)){
  sname = names(integrations)[i]
  sobj = FindNeighbors(sobj, reduction = integrations[[sname]], dims = 1:30, verbose = F)
  for (r in res){
    sobj = FindClusters(sobj, resolution = r, cluster.name = paste(sname,r,sep="_"), verbose = F)
  }
}

meta.clust = sobj@meta.data[,grepl("^seu_", colnames(sobj@meta.data))]
meta.clust = meta.clust[match(in.all, meta.seurat$cell),]

# all bioc
integrations = list(
  bio_mnn = "MNN",
  bio_harm = "harmony",
  bio_scan = "Scanorama"
)

for (i in 1:length(integrations)){
  sname = names(integrations)[i]
  bioc = FindNeighbors(bioc, reduction = integrations[[sname]], dims = 1:30, verbose = F)
  for (r in res){
    bioc = FindClusters(bioc, resolution = r, cluster.name = paste(sname,r,sep="_"), verbose = F)
  }
}

tmp = bioc@meta.data[,grepl("^bio_", colnames(bioc@meta.data))]
tmp = tmp[match(in.all, meta.bioc$cell),]
meta.clust = cbind(tmp, meta.clust)

# all scanpy
integrations = list(
  scpy_harm = "X_pca_harmony",
  scpy_scan = "Scanorama"
)

for (i in 1:length(integrations)){
  sname = names(integrations)[i]
  scanpy = FindNeighbors(scanpy, reduction = integrations[[sname]], dims = 1:30, verbose = F)
  for (r in res){
    scanpy = FindClusters(scanpy, resolution = r, cluster.name = paste(sname,r,sep="_"), verbose = F)
  }
}

tmp = scanpy@meta.data[,grepl("^scpy_", colnames(scanpy@meta.data))]
tmp = tmp[match(in.all, meta.scanpy$cell),]
meta.clust = cbind(tmp, meta.clust)



```

Calculate adjusted Rand index, with mclust package.


```{r}
#| fig-height: 10
#| fig-width: 12

ari = mat.or.vec(ncol(meta.clust), ncol(meta.clust))

for (i in 1:ncol(meta.clust)){
  for (j in 1:ncol(meta.clust)){
  ari[i,j] = mclust::adjustedRandIndex(meta.clust[,i], meta.clust[,j])
  }
}
rownames(ari) = colnames(meta.clust)
colnames(ari) = colnames(meta.clust)

annot = data.frame(Reduce(rbind,strsplit(colnames(meta.clust), "_")))
colnames(annot) = c("Pipe", "Integration", "Resolution")
rownames(annot) = colnames(meta.clust)
nclust = apply(meta.clust, 2, function(x) length(unique(x)))
annot$nClust = nclust
pheatmap::pheatmap(ari, annotation_row = annot)
```

All the scanorama ones are similar, except for the one with counts. Harmony on the bioc object also stands out as quite different. 

Number of clusters per method:

```{r}
nclust = apply(meta.clust, 2, function(x) length(unique(x)))
par(mar = c(3,10,3,3))
barplot(nclust, horiz=T, las=2, cex.names=0.6)
```

## Clustering consistency

Compare all these different clusterings by calculating how often each cell pair is in the same cluster.

```{r}
calculateCLProb = function(nC,nS){
    P = (nS/nC-1) / (nS-1)
    return(P)
}

clusterOverlapN <- function(meta.df){
  # meta.df is a data frame with clustering results in each column 
  dmats = list()
  probs = mat.or.vec(1,ncol(meta.df))
  for (i in 1:ncol(meta.df)){
    tmp = as(outer(meta.df[,i],meta.df[,i], FUN = "==")+0, "dgCMatrix")
    diag(tmp) = 0 #score to self to zero.
    # normalize the counts by probability given number of clusters and cells.
    prob = calculateCLProb(length(unique(meta.df[,i])),length(meta.df[,i]))
    probs[i] = prob
    tmp = tmp /prob
    dmats[[i]] = tmp
  }
  names(dmats) = colnames(meta.df)
  
  # add all matrices together, divide by number of matrices.
  sum.dist = Reduce("+",dmats)/ncol(meta.df)
  
  # scores each clustering by adding together the individual consensus scores for the cell pairs that we have. 
  # Divide by number of cells. 
  scores = lapply(dmats, function(x) sum(x*sum.dist)/nrow(meta.df)^2)
  scores = unlist(scores)
  names(scores) = colnames(meta.df)
  return(list(overlapMatrices = dmats, sumMatrix = sum.dist, scores = scores, probabilities = probs))
}
```


```{r}
stats = clusterOverlapN(meta.clust)

cs = colSums(stats$sumMatrix)
names(cs) = colnames(all)

all = AddMetaData(all, cs, col.name = "overlapN")
all = AddMetaData(all, log10(cs), col.name = "overlapN.log")


FeaturePlot(all, reduction = "umap_harmony", features = c("overlapN", "overlapN.log"))
```

For each cell, we have stats on how often it is in the same cluster as another cell. Ranging from 0 to nclust. 


Now we have a score for each pair of cells of how frequently they cluster together. So we can just multiply the matrices to see if high scoring cells are grouped in that clustering. 
But we need to adjust for cluster sizes, larger clusters have bigger chance of having a high score. So the scores are normalized by the number of clusters with `calculateCLProb`



```{r}
annot$Score = stats$scores
annot$Name = rownames(annot)
ggplot(annot, aes(x=Name, y=Score, color=Pipe, fill=Integration)) + geom_bar(stat = "identity") + RotatedAxis()
```

Generally high scores for harmony with Scanpy or Seurat, CCA clearly differs. But the scores are biased and only show what is closest to consensus.

## Clustering in the pipelines

Above, we did the clustering with the same method on the different integrated spaces. Now we will instead explore the integrated clustering from the different pipelines. We still only use the cells that are in common from all 3 pipelines. 

The graph clustering is implemented quite differently in the different pipelines.

* Seurat - runs detection on SNN, resolution implemented
* Scanpy - runs detection on KNN, resolution implemented
* Bioc - runs detection on SNN, but different scoring to Seurat, resolution parameter behaves strange. Instead use `k` to tweak cluster resolution.


```{r}
seu.columns = c("RNA_snn_res","kmeans_","hc_")
bioc.columns = c("louvain_","leiden_","hc_","kmeans_")
scpy.columns = c("leiden_","hclust_","kmeans_")
  

idx = which(rowSums(sapply(seu.columns, grepl, colnames(sobj@meta.data)))>0)
tmp1 = sobj@meta.data[match(in.all, meta.seurat$cell), idx]
colnames(tmp1) = paste0("seur_", colnames(tmp1))

idx = which(rowSums(sapply(bioc.columns, grepl, colnames(bioc@meta.data)))>0)
tmp2 = bioc@meta.data[match(in.all, meta.bioc$cell), idx]
colnames(tmp2) = paste0("bioc_", colnames(tmp2))

meta.clust2 = cbind(tmp1, tmp2)

idx = which(rowSums(sapply(scpy.columns, grepl, colnames(scanpy@meta.data)))>0)
tmp2 = scanpy@meta.data[match(in.all, meta.scanpy$cell), idx]
colnames(tmp2) = paste0("scpy_", colnames(tmp2))

meta.clust2 = cbind(meta.clust2, tmp2)
```


Group based on adjusted Rand index. 

```{r}
#| fig-height: 10
#| fig-width: 12

ari = mat.or.vec(ncol(meta.clust2), ncol(meta.clust2))

for (i in 1:ncol(meta.clust2)){
  for (j in 1:ncol(meta.clust2)){
  ari[i,j] = mclust::adjustedRandIndex(meta.clust2[,i], meta.clust2[,j])
  }
}
rownames(ari) = colnames(meta.clust2)
colnames(ari) = colnames(meta.clust2)


m = unlist(lapply(strsplit(colnames(meta.clust2), "_"), function(x) x[2]))
p = unlist(lapply(strsplit(colnames(meta.clust2), "_"), function(x) x[1]))
nc = apply(meta.clust2, 2, function(x) length(unique(x)))
       
annot = data.frame(Pipe=p, Method=m, nC=nc)
rownames(annot) = colnames(meta.clust2)
pheatmap::pheatmap(ari, annotation_row = annot)
```

Clustering consistency per cell

```{r}

stats2 = clusterOverlapN(meta.clust2)

cs = colSums(stats2$sumMatrix)
names(cs) = colnames(all)


all = AddMetaData(all, cs, col.name = "overlapN.all")
all = AddMetaData(all, log10(cs), col.name = "overlapN.all.log")


FeaturePlot(all, reduction = "umap_harmony", features = c("overlapN.all", "overlapN.all.log"))
```

Score each method based on how often they place high scoring cells in different clusters. 


```{r}
nclust2 = apply(meta.clust2,2, function(x) length(unique(x)))

par(mfrow = c(2,2))
plot(nclust2, stats2$scores)
plot(nclust2, stats2$scores/nclust2)
plot(nclust2, stats2$probabilities)

```

```{r}
annot$score = stats2$scores
annot$Name = rownames(annot)

ggplot(annot, aes(x=Name, y = score, fill=Pipe)) + geom_bar(stat = "identity") + RotatedAxis()

ggplot(annot, aes(x=nC, y = score, color=Pipe)) + geom_point()
```



## Save 

```{r}
saveRDS(all, "data/covid/results/merged_all.rds")
```


## {{< meta session >}}

<details>
  <summary>Click here</summary>

```{r}
sessionInfo()
```

</details>